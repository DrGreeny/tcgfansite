import mongodb from "../../utils/mongodb";
import User from "../../models/user";

const elliptic = require("elliptic");

// Verify signature using public key and message
function verifySignature(publicKey, message, signature) {
  console.log("Key: ", publicKey);
  const ec = new elliptic.ec("secp256k1");
  const key = ec.keyFromPublic(publicKey, "hex");
  return key.verify(message, signature);
}

export default async function handler(req, res) {
  if (req.method === "POST") {
    //await handleAuthentication(req, res);
    try {
      await mongodb.dbConnect();
      res.status(200).json({ message: "Authentication successful" });
    } catch (error) {
      console.error(error);
      res.status(500).json({ message: "Internal Server Error" });
    } finally {
      await mongodb.dbDisconnect();
    }
  } else {
    res.status(405).json({ message: "Method Not Allowed" });
  }
}

async function handleAuthentication(req, res) {
  try {
    await mongodb.dbConnect();

    const { signature, account } = req.body;

    // Find the user with the provided public address
    const user = await User.findOne({ publicAddress: account });
    if (!user) {
      res.status(404).json({ message: "User not found" });
      return;
    }
    // Example usage
    const publicKey = account.substring(2); // The public key associated with the signer's Ethereum address
    const message = `Authentication request: ${user.nonce}`; // The authentication request message
    // The signature generated by the signer

    const isSignatureValid = verifySignature(publicKey, message, signature);

    if (isSignatureValid) {
      console.log("Signature is valid");
      res.status(200).json({ message: "Authentication successful" });
    } else {
      console.log("Signature is invalid");
      res.status(500).json({ message: "Internal Server Error" });
    }
  } catch (error) {
    console.error(error);
  } finally {
    await mongodb.dbDisconnect();
  }
}
